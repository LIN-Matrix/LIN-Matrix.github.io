# day4 (4.17)

## 1. 研究伪实现到真实现

## 2. 参考师兄的博士论文第四章

### 2.X ArceOS 网络子系统 axnet 组件分析

在 ArceOS 的组件化体系中，网络功能由独立的 `axnet` 组件实现。该组件不仅承担了网络协议栈与底层网卡驱动之间的桥接职责，还面向应用层提供了统一的套接字（socket）接口，形成了完整的网络服务链路。

为适应不同应用场景下的性能与资源要求，`axnet` 支持多种网络协议栈的接入，目前集成了两种在嵌入式和实时系统中广泛使用的轻量级协议栈：**smoltcp**（基于 Rust 实现）和 **lwIP**（基于 C 语言实现）。这两个协议栈以组件化模块的形式存在，分别暴露出标准化的网卡设备抽象接口。开发者仅需在 `axdriver` 模块中实现该接口，即可将底层驱动与协议栈解耦组合，从而实现协议栈与物理设备之间的透明对接。

在此基础上，`axnet` 对两类协议栈的套接字接口进行了统一封装，提供了接近 POSIX 标准的 API 风格。主要支持的接口包括 `connect`、`bind`、`listen`、`accept`、`send` 和 `recv` 等 TCP 通用操作。同时，也支持 UDP 套接字、DNS 域名解析等基础网络功能，增强了组件的适用范围与可扩展性。

值得注意的是，为了尽可能提升网络处理性能，`axnet` 当前采用**基于轮询的访问模式**。在每次应用层调用套接字操作后，系统会主动轮询网卡状态：若检测到接收到的数据包，则立即将其上送协议栈以推进状态机处理流程；同时，也会检查协议栈中的发送缓冲区，并将待发送数据通过网卡发出。这种机制在无中断控制器或资源受限场景下具有较好的实时性和确定性。

此外，ArceOS 在数据包的收发路径上也引入了**零拷贝优化机制**。在数据接收过程中，系统预先为网卡分配一组缓冲区并注册至其接收队列，当数据包到达后，可直接传递缓冲区至协议栈处理，避免中间数据复制操作。处理完成后，缓冲区被复用回接收队列，进一步减少内存碎片和提升处理效率。

综上，`axnet` 模块以组件化的方式集成协议栈、网卡驱动和 POSIX 风格接口，并通过零拷贝优化与轮询机制提升数据处理性能，为后续宏内核模块（如 syscall 支持）中的网络功能扩展提供了良好基础。

## 3. BrickOS 中的相关工作

### 相关工作

1. **Software Dock**：该系统支持操作系统的组件化，采用基于代理的软件模型来管理生产者与消费者之间的交互。

2. **THINK**：采用组件化编程模型，定义了模块间的交互接口，允许灵活组装组件，创建适用于特定需求的操作系统。

3. **OpenCom**：另一种基于组件的系统，定义了一个最小的运行时内核，并通过模块化组件实现系统定制。该工作特别关注跨不同硬件平台的兼容性，其中硬件提供商提供模块加载器和链接器，系统开发者基于此进行应用开发。

4. **Unikraft**：一个开源的库操作系统，支持定制单地址空间的操作系统内核，主要面向在主机操作系统（如Linux）上运行的云虚拟机应用。

5. **FlexOS**：重点关注配置可隔离的机制，支持多种软硬协同的隔离策略，强调操作系统的安全性和可靠性。

6. **Pebble**：为特定应用程序设计的专用操作系统，采用服务器-客户端设计，包含一个精简的内核，能够根据领域特定的需求进一步精简。

## 4. 梳理论文大纲

[filename](../../asserts/0417/1.md ':include :type=markdown')